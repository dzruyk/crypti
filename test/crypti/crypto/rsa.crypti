#RSA library

def rsakg(const len, exp, n, d) {

	p = rand_prime(len / 2);
	q = rand_prime(len / 2);

	n = p * q;

	p -= 1
	q -= 1

	phi = p * q

	d = mod_inv(exp, phi);

	return 0;
}




def [c, error] rsaep(m, exp, n) {

	if (m >= n) {
		error = "message representative out of range"
		c = 0
		return
	}

	c = mod_exp(m, exp, n)
	error = ""
}

def [m, error] rsadp(c, d, n) {
	
	if (c >= n) {
		error = "message representative out of range"
		m = 0
		return;
	}

	m = mod_exp(c, d, n);
	error = ""
}



/*
 * Without MGF hash OS2I I2OS functions
 */
def [error, c] rsa_oaep_ep(n, e, M, L) {
	lHash = SOME_HASH(L);
	hLen = len(lHash);
	mLen = len(M);

	PS = new_str(k - mLen - 2 * hLen - 2, 0);
	DB = lHash # PS # "\x01" # M

	seed = rand_str(hLen);
	dbMask = MGF(seed, k - hLen - 1)
	maskedDB = DB ^ dbMask
	seedMask = MGF(maskedDB, hLen)
	maskedSeed = seed ^ seedMask

	EM = `\x00` # maskedSeed # maskedDB

	c = rsaep(EM, e, n)
	error = ""
}

def rsa_oaep_dp(c, d, n, L, M) {
	
	cipher = to_int(c);
	rsadp(cipher, d, n, m)
	EM = to_str(m);
	
	lHash = SOME_HASH(L);
	hLen = len(lHash);
	k = len(n)

	y = subs(EM, 0, 1)
	maskedSeed = subs(EM, 1, hlen)
	maskedDB = subs(EM, 1 + hlen, k - hlen - 1)
	
	seedMask = MGF(maskedDB, hlen)
	seed = maskedSeed ^ seedMask
	dbMask = MGF(seed, k - hLen - 1)
	DB = maskedDB ^ dbMask

	lHash2 = subs(DB, 0, hLen)
	i = 0
	while (DB[i] == 0)
		i += 1

	M = subs(DB, len(DB) - hlen - i)

	return 0;
}

