Черновик документации по crypti.

Для удобства файл будет разбит на 2 части
1) TODO - список изменений которые возможно следует
добавить в будущем (возможно что-то будет перекликаться с
TODO файлом в ./doc папке)
2) DOC - описание (пока не структурированное и не полное)
языка, разбитое на логические дополнительные части


TODO:
* const модификатор в функции.
* В переменной может храниться ссылка на функцию?
* Параметры передаются по в функцию по значению?
* Функции, которые должны изменить более одного аргумента?
* Элементы массивов могут быть разными типами?
* Так как функции принимают аргументы как копии нужно сделать 
    del ключевым словом а не функцией?

DOC:

Введение.

Типы переменных.
	Строки
	Числа
	Массивы

Лексические элементы.
	Идентификаторы
	Ключевые слова
		Условия, циклы
		break/continue
		return
		import
		def
	Числа
	Строки
	Массивы
		Определение
		Доступ к элементам
	Переменные
	Операторы
		Бинарные, унарные опреаторы
		Приоритет операций
	Функции
		Определение
		Вызов
		builtin функции
	Области видимости
		Глобальная область видимости.
		Локальные области видимости.

Модули.
	Подключение модуля
	Стандартные пути

Стандартная библиотека.
	Описание builtin модулей
	crypto
		mod_inv
		mod_exp
		rand_prime
	stdio
		num_from_file
		fopen
		fclose
		fread
		fwrite
	random

Введение.

Crypti - это интерпретируемый язык программирования с Си-подобным синтаксисом,
созданный, в основном, для реализации с помощью него различных криптографических алгоритмов.
Основная его особенность - нативная поддержка чисел произвольной длинны,
что позволяет программисту отвлечься низкоуровневых задач по контролю памяти и
созданию или использованию библиотеки больших чисел.

Типы переменных.

Crypti - язык со динамической типизацией (например как Python, Perl, PHP и т.д.),
т.е. тип переменной
определяется в момент присваивания,
но при этом Crypti строго типизирован.
Это означает то что операции с разными типами не допустимы и попытки проведения таких операций
будут приводить к ошибке (например: 2 + "string" приведёт к <Runtime error>).

Всего поддерживается 3 типа переменных:

1. Строки
	Представляют из себя последовательность однобайтовых символов.
	В отличие от C строк они не терменированны символом '\0'.
	Строки в crypti выглядят так,
	потому что в процессе криптографических преобразований один или несколько символов
	в середине строки могут стать равными 0,
	что привело бы к уменьшению длинны для C строк.
	В основном тип "строка" необходим для операций ввода вывода, 
	перевести строки в численное представление можно с помощью встроенной функции to_num().
	Примеры определения строк:
		"mystring"
		"m\x00\x01gg"
		и т.д.
2. Числа
	Целое число произвольной длинны.
	Программист не должен заботиться о увеличении/уменьшении размера числа, 
	это делается автоматически в процессе исполнения программы. 
	Иногда требуется перевести число в строку, 
	это можно сделать с помощью встроенной функции to_str().
	Примеры определения чисел:
		42
		1000012
		1234567890
		и т.д.
3. Массивы
	Представляют из себя набор чисел или строк,
	В crypti все массивы являются ассоциативными, т.е. индексом массива
	может быть как числа так и строки.
       	Индекс указывается в квадратных скобках.
	Многомерные массивы не поддерживаются.
	Элементом массива может быть как строки так и числа.

	Примеры опеределения массивов:
		arr[1] = "my";
		arr["name"] = 1;
		arr["job"] = "programming";
	
Лексические элементы.

Идентификаторы
	Идентификаторы можно задать в соответствии со следующим регулярным выражением.
	[a-zA-Z][a-zA-Z0-9]*

ключевые слова
	if/else
		выражение if используется для условного ветвления:
		if (condition) block1 
		[else block2]

		block1 выполняется только в том случае если condition не равно 0.
	while
		while используется для последовательного выполнения блока кода пока
		условие верно.
		while (condition) block;

		Если condition не указано то 
		получившийся цикл аналогичен этому:

		while (1)
			block;
	
	do
		do block while(condition)

		выражение эквивалентно выражению:
		
		block;
		while(condition) block

	for
		for (expr1; condition; expr2) body;
		
		цикл for аналогичен данному циклу while:

		expr1;
		while (condition) {
			body
			expr2
		}
		
		expr1, expr2 и condition могут быть пустыми
		
	break
		break может встречаться только внутри циклов
		for, while, do...while, его выполнение
		приводит к немедленному
		выходу из внутреннего охватывающего цикла.

	continue
		Как и break, continue может встречаться только
		внутри циклов for, while, do...while. Его выполнение
		приводит к немедленному переходу
		на следующую итерацию цикла.

	return 
		return [expression]
		return должен встречаться в теле функции.
		он приводит немедленному завершению функции.
		Если указано expression то функцией возвращается
		результат его выполения.

	import
		import "modname"
		import <modname>
		Ключевое слово, позволяющее импортировать модули в
		область главную область видимости.
		import должен присутствовать в глобальной области видимости
		(внутри условий, циклов,
		вложенных областях видимости import не обрабатывается).

	def
		def funcname(param1, param2, ...) {
			block
		}
		Ключевое слово,
		позволяющее определить новую 
		или перепреоделить уже существующую функцию.
		Переопределение встроенных функций приводит к ошибке.
Числа
	В  crypti используются только целые числа.
	Они могут быть записаны в нескольких системах счисления:
	1. Десятичной:
		Запись производится в соответствии с регулярным выражением
		[+-]*[0-9]+
	2. Шестнадцатиричной:
		Число записывается с помощью регулярного выражения:
		[+-]*0x[0-9A-F]+
	Если перед числом указано больше одного знака,
	то результирующий знак определяется по следующему правилу:
		-) Если количество минусов перед знаком нечётное
		+) В противном случае
Строки
	Как уже было сказано строка - это произвольный набор символов,
	заключённый в двойные кавычки.
	Непечатные символы,
	содержащиеся в строке экранируются последовательностью '\x'
	с указанием кодасимвола.
	Размер строки задаётся при её инициализации,
	и сохраняется до освобождения памяти.
	С помощью индекса можно получить доступ к произвольному байту строки,
	при этом возвращаемое значение будет автоматически преобразовано в число.

Массивы
	Определение
	
	Массивы определяются с помощью перечисленных через запятую пар ключ => значение,
	заключённых в фигурные скобки, где ключ служет индексом в массиве для доступа
	к этому значению.
	Например:
		arr = {"one" => 1, "two" => 2}
	Так же элементы массива можно определить по очереди
	Например написанное выше можно переписать как:
		arr["one"] = 1; arr["two"] = 2
	
	Если в определении ключи отсутствуют то по умолчанию значения размещаются в ячейках
	с индексом начиная с 0 и далее.
	Например:
		arr = {"one", 2, 3, "some"}
		значение "one" будет доступно при обращении arr[0],
		значение 2 при обращении arr[1] и так далее.
	Элементами массивов могут быть данные любых типов.

	Доступ к элементам.
	Доступ к элементам массива происходит посредством передачи значения
	между квадратными скобками.
	Например:
		arr[1]
		arr["two"]
		arr["42"]
	Попытка доступа к несуществующему элементу будет приводить к <Runtime error>
		
Переменные
	Переменная - это идентификатор и ассоциированная с ним область данных.

Операторы

Ниже приведён список доступных операторов.
Если не будет указано то операторы бинарные.

операторы:
	
	Арифметические операторы:
	+
		Если операнды числа - складывает их
		Если операнды строки - возвращает строку,
		являющуюся конкатенацией операндов.
		В противном случае ошибка.
	-
		Если операнды числа - производит вычитание.
		В противном случае ошибка.
	*
		Если операторы числа - производит перемножение.
		В противном случае ошибка.
		
	/

	%

	^
	|
	&
	>>
	<<
	
	
	Операторы присваивания:

	=
	op=

	Логические операторы:
	&&
	||
	!

Приоритетность
	В таблице, приведённой ниже операторы перечисленны
	по возрастающей приоритетности.

	ТАБЛИЦА

	Обозначения:
		LR очерёдность слева на право.
		RL очерёдность справа на лево.

Функции

Функции - набор логически выделенных инструкций, вызываемых по требованию.
В crypti все определённые функции (включая встроеные) хрянятся в отдельной
таблице, однако во избежание путанницы интерпретатор реализован так,
что функции не могут иметь те же имена что переменные.
По умолчанию параметры, переданные в функцию передаются как копии. 
То есть их изменение внутри функции не повлияет
на значения после вызова.
Если необходимо что бы функция изменяла переданный параметер,
при определении функции перед данным параметром указывается ключевое слово
"SOME_WORD"
Пример:
	a = 2
	def func(SOME_WORD b) {
		b += 2;
	}
	func(a);

После вызова функции func a будет равно 4

	Определение
		Определение функции заносит новую функцию в таблицу,
		если функция уже присутствует в таблице и не является
		встроенной, то старое определение заменится новым.
		Переопределение встроенных функций не допускается.

		Функция определяется таким образом:

		def func_name(parameter_list) {
			body
		}

		Где:
		func_name - идентификатор,
		являющийся именем функции.
		parameter_list - перечисленные через запятую идентификаторы, являющиеся аргументами функции
		body - набор инструкций, выполняемых при вызове функции.
		Для блока инструкций внутри тела функции создаётся
		отдельная область видимости (см. Области видимости),
		локальные переменные определённые в ней пропадают
		в момент выхода из функции.

	Вызов
		Вызов функции осуществляется с помощью конструкции

		func_name(parameter_list)

		Где:
		func_name - идентификатор уже определённой функции.
		parameter_name - перечисленные через запятую выражения,
		результаты которых будут являться аргументами функции.

	builtin функции.

	В Crypti содержится несколько встроеных функций,
	Эти функции не могут быть переопределены или удалены 
	они всегда доступны для вызова.
	Ниже в алфавитном порядке перечисленны сами функции.

	del(var)
		Удаляет переменную из ближайшей области видимости,
		и освобождает всю занимаемую ей память.

	print(var, ...);
		выводит на stdout переданные аргументы.

	printf([format_string], ...)
		Выводит на stdout переданные аргументы в соответствии с форматной строкой.
		При нехватке/переизбытке агрументов указанных в форматной строке печатает
		предупредительное соообщение

	to_num(string)
		Возвращает целочисленное представление переданной переменной
		строкового типа.
		Если переданная переменная не 

	to_str(bignum)
		Возвращает строковое представление переданной переменной целочисленного типа.
		Если переданная переменная не число, возвращает пустую строку ""


Области видимости

Область видимости содержит в себе набор
имён переменных и ассоциированных с ними данных.

Для каждого блока инструкций обрамлённого символами '{' и '}'
и для каждого вызова функции создаётся своя область видимости.
	Пример:
		{
			a = 2
			b = 4
		}
Это значит что все определённые в этой области видимости переменные
доступны только в этой области видимости,
и доступ к ним при выходе из этой области невозможен.
Поиск переменной происходит от текущей области видимости к глобальной.
Это значит что программа может пользоваться переменными из области
видимости меньшего уровня вложенности.

	Глобальная область видимости.
		Внешняя область видимости.
		В ней доступны инструкции для подключения модулей,
		возможость определения новых функций.

	Локальные области видимости.
		

Модули

Модуль это файл, написаный на языке crypti и импортированный в программу
с помощью инструкции import.
Все функции и переменные, определённые в модуле,
импортируются в глобальную область видимости.
для предотвращения бесконечного импортирования модулей
(например когда модуль А импортирует модуль Б,
а тот в свою очередь импортирует модуль А)
информация об импортированном модуле заносится в таблицу импорта.
При каждой новой попытке импорта проверяется таблица импорта,
и если данный модуль уже импортирован, то запрос импорта пропускается.
Это означает что если произошёл импорт,
и затем произошли изменения в модуле то не существует никакого способа
обновления данных модуля. Возможно в следующих версиях интерпретатора
будет реализована специальная инструкция "require",
с помощью которой будет доступна перезагрузка содержания модуля.

	Подключение 
		Модули подключаются с помощью ключевого слова import.
		Если подключается модуль из стандартной библиотеки то
		имя модуля обрамляется символами '<' и '>'.
		Пример:
			import <crypto>
		Если подключается файл, определённый пользователем,
		то указывается относительный от данного каталога путь,
		обрамлённый символами двойной кавычки.
		Пример:
			import "crypto"

	Стандартные пути расположения модулей


Стандартная библиотека.
	Описание builtin модулей

	1. crypto
	mod_inv(num, modulo)
		находит обратное num число по модулю modulo

	mod_exp(res, n, exp, modulo)
		вычисляет
		(n ** exp) % modulo
		
	rand_prime(len)
		генерирует случайное число длиннной len байт
	
	2. stdio
	num_from_file()
	fopen()
	fclose()
	fread()
	fwrite()
	
	3.random

	4.string
	
	new_string(len, filler)
		возвращает новую строку len байт длинны.
		каждый байт строки равен filler.

