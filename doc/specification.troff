Черновик документации по crypti.

Для удобства файл будет разбит на 2 части
1) TODO - список изменений которые возможно следует
добавить в будущем (возможно что-то будет перекликаться с
TODO файлом в ./doc папке)
2) DOC - описание (пока не структурированное и не полное)
языка, разбитое на логические дополнительные части


TODO:
* const модификатор в функции.
* В переменной может храниться ссылка на функцию?
* Параметры передаются по в функцию по значению?
* Функции, которые должны изменить более одного аргумента?
* Элементы массивов могут быть разными типами?
* Так как функции принимают аргументы как копии нужно сделать 
    del ключевым словом а не функцией?

DOC:

Введение.

Типы переменных.
	Строки
	Числа
	Массивы

Преобразование типов

Лексические элементы.
	Идентификаторы
	Ключевые слова
		Условия, циклы
		break/continue
		return
		import
		def
	Массивы
		Определение
		Доступ к элементам
	Переменные
	Операторы
		Бинарные, унарные опреаторы
		Приоритет операций
	Функции
		Определение
		Вызов
		builtin функции
	Области видимости
		Глобальная область видимости.
		Локальные области видимости.

Модули.
	Подключение модуля
	Стандартные пути

Стандартная библиотека.
	Описание builtin модулей
	crypto
		mod_inv
		mod_exp
		rand_prime
	stdio
		num_from_file
		fopen
		fclose
		fread
		fwrite
	random

Введение.

Crypti - это интерпретируемый язык программирования с Си-подобным синтаксисом,
созданный, в основном, для реализации с помощью него различных криптографических алгоритмов.
Основная его особенность - нативная поддержка чисел произвольной длинны,
что позволяет программисту отвлечься низкоуровневых задач по контролю памяти и
созданию или использованию библиотеки больших чисел.

Типы переменных.

Crypti - язык со динамической типизацией (например как Python, Perl, PHP и т.д.),
т.е. тип переменной
определяется в момент присваивания,
при этом Crypti слабо типизирован, и тип конкретной переменной определяется в процессе использования.
Это означает то что можно просто осуществлять операции с переменными разных типов,
не заботясь о явном преобразовании. Например:
a = 42
b = a " universe"
сначала преобразует a в строку, а потом произведёт конкатенацию строки "42" и строки " universe",
в итоге в b будет содержатья строка "42 universe"

Всего поддерживается 3 типа переменных:

1. Числа
	В  crypti используются только целые числа.
	Они могут быть записаны в нескольких системах счисления:
	1. Десятичной:
		Запись производится в соответствии с регулярным выражением
		[+-]*[0-9]+
	2. Шестнадцатиричной:
		Число записывается с помощью регулярного выражения:
		[+-]*0x[0-9A-F]+
	Если перед числом указано больше одного знака,
	то результирующий знак определяется по следующему правилу:
		-) Если количество минусов перед знаком нечётное
		+) В противном случае
	Программист не должен заботиться о увеличении/уменьшении размера числа, 
	это делается автоматически в процессе исполнения программы. 
	Примеры определения чисел:
		42
		1000012
		1234567890
		и т.д.

2. Октетные строки
	Представляют из себя последовательность однобайтовых символов.
	В отличие от C строк они не терменированны символом '\0'.
	Октетные строки в crypti выглядят так,
	потому что в процессе криптографических преобразований один или несколько символов
	в середине строки могут стать равными 0,
	что привело бы к уменьшению длины для C строк.
	В основном этот тип необходим для операций, производимых над последовательностями байтов,
	например конкатенации.
	Примеры определения октетных строк:
		'\x00\x44\x23\x11'
		'\x0d\x0a\x42'

3. Печатаемые строки
	Аналог обычной С строки, терминированной нулём, и содержащей в себе
	печатную информацию о содержании переменной.
	В основном этот тип необходим для операций ввода вывода,  
	Примеры определения печатных строк:
		"mystring"
		"m\x00\x01gg"
		и т.д.

Преобразование типов.
	Преобразование типов происходит динамически, в зависимости от места использования переменной.

	Следует помнить несколько правил преобразования типов:
	1) Не все преобразования возвратны.
		Тип Октетная строка не хранит знака числа. Преобразование отридцательного числа
		в октетную строку выдаёт предупреждение на stderr о потере знака.
		
	2) Преобразование из печатной строки в число не всегда успешно.
		Если печатная строка содержит символы, не являющиеся цифрами, она будет интерпретирована как 0 
		и на stderr будет выведено предупреждение.

Лексические элементы.

Идентификаторы
	Идентификаторы можно задать в соответствии со следующим регулярным выражением.
	[a-zA-Z][a-zA-Z0-9]*

ключевые слова
	if/else
		выражение if используется для условного ветвления:
		if (condition) block1 
		[else block2]

		block1 выполняется только в том случае если condition не равно 0.
	while
		while используется для последовательного выполнения блока кода пока
		условие верно.
		while (condition) block;

		Если condition не указано то 
		получившийся цикл аналогичен этому:

		while (1)
			block;
	
	do
		do block while(condition)

		выражение эквивалентно выражению:
		
		block;
		while(condition) block

	for
		for (expr1; condition; expr2) body;
		
		цикл for аналогичен данному циклу while:

		expr1;
		while (condition) {
			body
			expr2
		}
		
		expr1, expr2 и condition могут быть пустыми
		
	break
		break может встречаться только внутри циклов
		for, while, do...while, его выполнение
		приводит к немедленному
		выходу из внутреннего охватывающего цикла.

	continue
		Как и break, continue может встречаться только
		внутри циклов for, while, do...while. Его выполнение
		приводит к немедленному переходу
		на следующую итерацию цикла.

	return 
		return
		return должен встречаться в теле функции.
		он приводит немедленному завершению функции.
		При этом возвращаются текущие значения возвращаемых параметров функции.

	import
		import "modname"
		import <modname>
		Ключевое слово, позволяющее импортировать модули в
		область главную область видимости.
		import должен присутствовать в глобальной области видимости
		(внутри условий, циклов,
		вложенных областях видимости import не обрабатывается).

	def
		def [ret1, ret2] funcname(param1, param2, ...) {
			block
		}
		Ключевое слово,
		позволяющее определить новую 
		или перепреоделить уже существующую функцию.
		Переопределение встроенных функций приводит к ошибке.

Массивы
	Представляют из себя набор чисел или строк,
	В crypti все массивы являются ассоциативными, т.е. индексом массива
	может быть как числа так и строки.
       	Индекс состоит из перечисленных через символ разделения записей выражений
	и указывается в квадратных скобках.
	За счёт этого достигается эмуляция многомерных массивов.

	Примеры опеределения массивов:
		arr[1] = "my";
		arr["name"] = 1;
		arr["job"] = "programming";
		arr["example", "of", "multidimentional", "array"] = "there";
	
	Определение
	
	Массивы определяются с помощью перечисленных через запятую пар ключ => значение,
	заключённых в фигурные скобки, где ключ служет индексом в массиве для доступа
	к этому значению.
	Например:
		arr = {"one" => 1, "two" => 2}
	Так же элементы массива можно определить по очереди
	Например написанное выше можно переписать как:
		arr["one"] = 1; arr["two"] = 2
	
	Если в определении ключи отсутствуют то по умолчанию значения размещаются в ячейках
	с индексом начиная с 0 и далее.
	Например:
		arr = {"one", 2, 3, "some"}
		значение "one" будет доступно при обращении arr[0],
		значение 2 при обращении arr[1] и так далее.
	Элементами массивов могут быть данные любых типов.

	Доступ к элементам.
	Доступ к элементам массива происходит посредством передачи значения
	между квадратными скобками.
	Например:
		arr[1]
		arr["two"]
		arr["42"]
	Попытка доступа к несуществующему элементу будет приводить к <Runtime error>
		
Переменные
	Переменная - это идентификатор и ассоциированная с ним область данных.

Операторы

Ниже приведён список доступных операторов.
Если не будет указано то операторы бинарные.

операторы:
	
	Арифметические операторы:
	+
		Представляет операнды как числа и складывает их.
	-
		Представляет операнды как числа и производит вычитание.
	*
		Представляет операнды как числа и производит умножение.
	/
		Представляет операнды как числа и производит деление.
	**
		Представляет операнды как числа и производит возведение левого операнда в степень 
		значения левого операнда.
	%
		Представляет операнды как числа и производит взятие остатка от деления.

	^
	|
	&
	>>
	<<
	
	
	Операторы присваивания:

	=
		присваивает значение правого операнда левому.
		Доступно параллельное присванивание, т.е. присваивание сразу нескольких пар значений.
		Например:
			[a, b] = [b, a]
			[n, l, y] = func_with_3_outputs()
	op=

	Логические операторы:
	&&
	||
	!

	Операторы с октетными строками

	Операторы с печатными строками

Приоритетность
	В таблице, приведённой ниже операторы перечисленны
	по возрастающей приоритетности.

	ТАБЛИЦА

	Обозначения:
		LR очерёдность слева на право.
		RL очерёдность справа на лево.

Функции

Функции - набор логически выделенных инструкций, вызываемых по требованию.
В crypti все определённые функции (включая встроеные) хрянятся в отдельной
таблице, однако во избежание путанницы интерпретатор реализован так,
что функции не могут иметь те же имена что переменные.
По умолчанию параметры, переданные в функцию передаются как копии.
То есть их изменение внутри функции не повлияет
на значения после вызова.
Если необходимо что бы функция изменяла переданный параметер,
при определении функции перед данным параметром указывается ключевое слово
"SOME_WORD"
Возвращаемые значения записываются в квадратных скобках при определении функции.
При достижении конца функции или ключевого слова return возвращаются их текущие значения
Если на момент выхода из функции одно или несколько значений не определены - 
генерируется <Runtime error>

Пример:
	a = 2
	def [] func(SOME_WORD b) {
		b += 2;
	}
	func(a);

После вызова функции func a будет равно 4

	Определение
		Определение функции заносит новую функцию в таблицу,
		если функция уже присутствует в таблице и не является
		встроенной, то старое определение заменится новым.
		Переопределение встроенных функций не допускается.

		Функция определяется таким образом:

		def [ret1, ret2] func_name(parameter_list) {
			body
		}

		Где:
		[ret1, ret2] - список возвращаемых функцией аргументов (который может быть пустым)
		func_name - идентификатор,
		являющийся именем функции.
		parameter_list - перечисленные через запятую идентификаторы, являющиеся аргументами функции
		body - набор инструкций, выполняемых при вызове функции.
		Для блока инструкций внутри тела функции создаётся
		отдельная область видимости (см. Области видимости),
		локальные переменные определённые в ней пропадают
		в момент выхода из функции.

	Вызов
		Вызов функции осуществляется с помощью конструкции

		func_name(parameter_list)

		Где:
		func_name - идентификатор уже определённой функции.
		parameter_name - перечисленные через запятую выражения,
		результаты которых будут являться аргументами функции.

	builtin функции.

	В Crypti содержится несколько встроеных функций,
	Эти функции не могут быть переопределены или удалены 
	они всегда доступны для вызова.
	Ниже в алфавитном порядке перечисленны сами функции.

	del(var)
		Удаляет переменную из ближайшей области видимости,
		и освобождает всю занимаемую ей память.

	print(var, ...);
		выводит на stdout переданные аргументы.

	printf([format_string], ...)
		Выводит на stdout переданные аргументы в соответствии с форматной строкой.
		При нехватке/переизбытке агрументов указанных в форматной строке печатает
		предупредительное соообщение

Области видимости

Область видимости содержит в себе набор
имён переменных и ассоциированных с ними данных.

Для каждого блока инструкций обрамлённого символами '{' и '}'
и для каждого вызова функции создаётся своя область видимости.
	Пример:
		{
			a = 2
			b = 4
		}
Это значит что все определённые в этой области видимости переменные
доступны только в этой области видимости,
и доступ к ним при выходе из этой области невозможен.
Поиск переменной происходит от текущей области видимости к глобальной.
Это значит что программа может пользоваться переменными из области
видимости меньшего уровня вложенности.

	Глобальная область видимости.
		Внешняя область видимости.
		В ней доступны инструкции для подключения модулей,
		возможость определения новых функций.

	Локальные области видимости.
		

Модули

Модуль это файл, написаный на языке crypti и импортированный в программу
с помощью инструкции import.
Все функции и переменные, определённые в модуле,
импортируются в глобальную область видимости.
для предотвращения бесконечного импортирования модулей
(например когда модуль А импортирует модуль Б,
а тот в свою очередь импортирует модуль А)
информация об импортированном модуле заносится в таблицу импорта.
При каждой новой попытке импорта проверяется таблица импорта,
и если данный модуль уже импортирован, то запрос импорта пропускается.
Это означает что если произошёл импорт,
и затем произошли изменения в модуле то не существует никакого способа
обновления данных модуля. Возможно в следующих версиях интерпретатора
будет реализована специальная инструкция "require",
с помощью которой будет доступна перезагрузка содержания модуля.

	Подключение 
		Модули подключаются с помощью ключевого слова import.
		Если подключается модуль из стандартной библиотеки то
		имя модуля обрамляется символами '<' и '>'.
		Пример:
			import <crypto>
		Если подключается файл, определённый пользователем,
		то указывается относительный от данного каталога путь,
		обрамлённый символами двойной кавычки.
		Пример:
			import "crypto"

	Стандартные пути расположения модулей


Стандартная библиотека.
	Описание builtin модулей

	1. crypto
	mod_inv(num, modulo)
		Находит обратное num число по модулю modulo.

	mod_exp(res, n, exp, modulo)
		Вычисляет
		(n ** exp) % modulo
		
	rand_prime(len)
		Генерирует случайное число длиннной len байт.
	
	2. stdio
	num_from_file()
	fopen()
	fclose()
	fread()
	fwrite()
	
	3.random

	4.string
	
	new_string(len, filler)
		Возвращает новую строку len байт длинны,
		каждый байт которой равен filler.
	subs(string, start, len)
		Возвращает копию подстроки начиная с start,
		len байт длинной.

