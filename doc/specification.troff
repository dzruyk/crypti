черновик документации по crypti.

Для удобства файл будет разбит на 2 части
1) TODO - список изменений которые возможно следует
добавить в будущем (возможно что-то будет перекликаться с
TODO файлом в ./doc папке)
2) DOC - описание (пока не структурированное и не полное)
языка, разбитое на логические дополнительные части



TODO:
const модификатор в функции

в переменной может храниться ссылка на функцию?

DOC:

Введение.

Типы переменных.
	строки
	числа
	массивы

Лексические элементы.
	Переменные.
	Ключевые слова
		условия циклы
		break/continue
		return
		import
	Числа
		тип записи чисел
	строки
		строки
	Арифметические операции:
		Бинарные, унарные опреаторы
		Приоритет операций
	Функции.
		Определение
		Вызов
		builtin функции


Области видимости.

Модули.
	Подключение модуля
	Стандартные пути

Стандартная библиотека.
	описание builtin модулей
	import crypto
		mod_inv
		mod_exp
		rand_prime

Введение.

Crypti - это интерпретируемый язык программирования с Си-подобным синтаксисом,
созданный, в основном, для реализации с помощью него различных криптографических алгоритмов.
Основная его особенность - нативная поддержка чисел произвольной длинны,
что позволяет программисту отвлечься низкоуровневых задач по контролю памяти и
созданию или использованию библиотеки больших чисел.

Типы переменных.

Crypti - язык со динамической типизацией (например как Python, Perl, PHP и т.д.),
т.е. тип переменной
определяется в момент присваивания,
но при этом Crypti строго типизирован.
Это означает то что операции с разными типами не допустимы и попытки проведения таких операций
будут приводить к ошибке (например: 2 + "string" приведёт к <Runtime error>).

Всего поддерживается 3 типа переменных:
1. Строки
	Представляют из себя последовательность однобайтовых символов.
	В отличие от C строк они не терменированны символом '\0'.
	Строки в crypti выглядят так,
	потому что в процессе криптографических преобразований один или несколько символов
	в середине строки могут стать равными 0,
	что привело бы к уменьшению длинны для C строк.
	В основном тип "строка" необходим для операций ввода вывода, 
	перевести строки в численное представление можно с помощью встроенной функции to_num().
	Примеры определения строк:
		"mystring"
		"m\x00\x01gg"
		и т.д.
2. Числа
	Целое число произвольной длинны.
	Программист не должен заботиться о увеличении/уменьшении размера числа, 
	это делается автоматически в процессе исполнения программы. 
	Иногда требуется перевести число в строку, 
	это можно сделать с помощью встроенной функции to_str().
	Примеры определения чисел:
		42
		1000012
		1234567890
		и т.д.
3. Массивы
	Представляют из себя набор чисел или строк,
	доступ к которым можно получить с помощью индекса.
	Crypti так же поддерживает многомерные массивы,
	доступ к элементам которых можно получить с помощью набора индексов.
	Индекс указывается в квадратных скобках, 
	например '[i][j][k]' при обращении к массиву с помощью меньшего набора
	индексов чем его мерность программист получает копию части массива,
	к которой происходит обращение. Например:
		arr = {{"my", "hobby"}, {"is", "programming"}}
		arr[0]
		возвратит 
		{"my", "hobby"}
	При обращении к конкретному элементу возвращается копия этого элемента.
	Т.е. если бы в прошлом примере мы
	написали arr[1][1] то возвратилась бы копия элемента "programming".

	Примеры опеределения массивов:
		{1,2,3}
		{"one", "two", "three"}
		{{1,2,3}}
		{{1,2},{3,4},{5,6}}
	
Лексические элементы.

переменные
ключевые слова
	if/else
	break
	continue
	return
	import
числа
строки
арифметические операции
	операторы
	приоритетность
функции
	определение

	вызов

	builtin функции.

	в Crypti содержится несколько встроеных функций,
	Эти функции не могут быть переопределены или удалены 
	они всегда доступны для вызова.
	Ниже в алфавитном порядке перечисленны сами функции.
	del(var)

	print(var, ...);
	printf([format_string], ...)

	to_num(string)

	to_str(bignum)

		

Области видимости

Модули
	подклечение 

	стандартные пути расположения модулей

Стандартная библиотека.
	описание builtin модулей

	1. crypto
	mod_inv(num, modulo)
		находит обратное num число по модулю modulo

	mod_exp(res, n, exp, modulo)

		(n ** exp) % modulo
		
	rand_prime(len)
