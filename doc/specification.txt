Черновик документации по crypti.
===============================

Notes
-----
Для удобства файл будет разбит на 2 части
1) TODO - список изменений которые возможно следует
добавить в будущем (возможно что-то будет перекликаться с
TODO файлом в ./doc папке)
2) DOC - описание (пока не структурированное и не полное)
языка, разбитое на логические дополнительные части

TODO:
-----
* const модификатор в функции.
* В переменной может храниться ссылка на функцию?
* Параметры передаются по в функцию по значению?
* Функции, которые должны изменить более одного аргумента?
* Элементы массивов могут быть разными типами?
* Так как функции принимают аргументы как копии нужно сделать 
    del ключевым словом а не функцией?

Содержание:
-----------

Введение.

Типы переменных.
	Строки
	Числа
	Массивы

Преобразование типов

Лексические элементы.
	Идентификаторы
	Ключевые слова
		Условия, циклы
		break/continue
		return
		import
		def
	Массивы
		Определение
		Доступ к элементам
	Переменные
	Операторы
		Бинарные, унарные опреаторы
		Приоритет операций
	Функции
		Определение
		Вызов
		builtin функции
	Области видимости
		Глобальная область видимости.
		Локальные области видимости.

Модули.
	Подключение модуля
	Стандартные пути

Стандартная библиотека.
	Описание builtin модулей
	crypto
		mod_inv
		mod_exp
		rand_prime
	stdio
		num_from_file
		fopen
		fclose
		fread
		fwrite
	random

Введение.
--------
Часто при реализации какого-либо криптографического протокола или алгоритма
необходимо быстро получить вектора для тестирования. Для этого необходимо иметь набор
инструментов, позволяющий быстро прототипировать выбранный протокол или алгоритм.
Crypti - это интерпретируемый язык программирования с Си-подобным синтаксисом разработанный
для этих целей, основные его особенности:

- Нативная поддержка чисел произвольной длинны,
что позволяет программисту отвлечься низкоуровневых задач по контролю памяти и
созданию или использованию библиотеки больших чисел;
- Набор криптографических примитивов (хеш функции, симметричные и ассиметричные алгоритмы)
позволяющих осуществлять быстрое прототипирование алгоритмов;
- Использование библиотеки больших чисел, содержащей множество теоретико-числовых алгоритмов
для операций с числами;
- Слабая типизация, позволяющая преобразовывать содержание переменной в нужный программисту тип
без вызова дополнительных функций в скрипте;
- Интерпретатор и все встроенные криптоалгоритмы реализованы на языке C, 
что позволяет достичь высокой производительности.


Типы переменных.
---------------
Crypti - язык со слабой динамической типизацией (например как Perl, PHP и т.д.),
т.е. тип переменной выбирается в зависимости от места её использования.
Это означает то что можно просто осуществлять операции с переменными разных типов,
не заботясь о явном преобразовании. Например:
a = 42
b = a " universe"
сначала преобразует a в строку, а потом произведёт конкатенацию строки "42" и строки " universe",
в итоге в b будет содержатья строка "42 universe"

Всего поддерживается 3 типа переменных:

1. Числа
~~~~~~~~
В  crypti используются только целые знаковые числа неограниченной размерности.
Они могут быть записаны в нескольких системах счисления:
1. Десятичной:
	Запись производится в соответствии с регулярным выражением
	[+-]*[0-9]+
2. Шестнадцатиричной:
	Число записывается с помощью регулярного выражения:
	[+-]*0x[0-9A-F]+
Если перед числом указано больше одного знака,
то результирующий знак определяется по следующему правилу:
	-) Если количество минусов перед знаком нечётное
	+) В противном случае
Примеры определения чисел:
	42
	1000012
	1234567890
	и т.д.

2. Октетные строки
~~~~~~~~~~~~~~~~~~
Представляют из себя последовательность однобайтовых символов.
В отличие от C строк они не терменируются символом '\0'.
Октетные строки в crypti выглядят так,
потому что в процессе криптографических преобразований один или несколько символов
в середине строки могут стать равными 0,
что привело бы к уменьшению длины для C строк.
В основном этот тип необходим для операций, производимых над последовательностями байтов,
например конкатенации.
Примеры определения октетных строк:
	'\x00\x44\x23\x11'
	'\x0d\x0a\x42'

3. Печатаемые строки
~~~~~~~~~~~~~~~~~~~~
Аналог обычной С строки, терминированной нулём, и содержащей в себе
печатную информацию о содержании переменной.
В основном этот тип необходим для операций ввода вывода,  
Примеры определения печатных строк:
	"mystring"
	"m\x00\x01gg"
	и т.д.

Преобразование типов.
--------------------
Преобразование типов происходит динамически, в зависимости от места использования переменной.

Следует помнить несколько правил преобразования типов:
1) Не все преобразования возвратны.
	Тип Октетная строка не хранит знака числа. Преобразование отрицательного числа
	в октетную строку выдаёт предупреждение на stderr о потере знака.
	
2) Преобразование из печатной строки в число не всегда успешно.
	Если печатная строка содержит символы, не являющиеся цифрами, она будет интерпретирована как 0 
	и на stderr будет выведено предупреждение.

Лексические элементы.
--------------------
Идентификаторы
~~~~~~~~~~~~~~
Идентификаторы можно задать в соответствии со следующим регулярным выражением.
[a-zA-Z][a-zA-Z0-9]*

Ключевые слова
~~~~~~~~~~~~~~
if/else
	выражение if используется для условного ветвления:
	if (condition) block1 
	[else block2]

	block1 выполняется только в том случае если condition не равно 0.
while
	while используется для последовательного выполнения блока кода пока
	условие верно.
	while (condition) block;

	Если condition не указано то 
	получившийся цикл аналогичен этому:

	while (1)
		block;

do
	do block while(condition)

	выражение эквивалентно выражению:
	
	block;
	while(condition) block

for
	for (expr1; condition; expr2) block;
	
	цикл for аналогичен данному циклу while:

	expr1;
	while (condition) {
		block
		expr2
	}
	
	expr1, expr2 и condition могут быть пустыми
	
break
	break может встречаться только внутри циклов
	for, while, do...while, его выполнение
	приводит к немедленному
	выходу из внутреннего охватывающего цикла.

continue
	Как и break, continue может встречаться только
	внутри циклов for, while, do...while. Его выполнение
	приводит к немедленному переходу
	на следующую итерацию цикла.

return 
	return
	return должен встречаться в теле функции.
	он приводит немедленному завершению функции.
	При этом возвращаются текущие значения возвращаемых параметров функции.

import
	import "modname"
	import <modname>
	Ключевое слово, позволяющее импортировать модули в
	область главную область видимости.
	import должен присутствовать в глобальной области видимости
	(внутри условий, циклов,
	вложенных областях видимости import не обрабатывается).

def
	def [ret1, ret2] funcname(param1, param2, ...) {
		block
	}
	Ключевое слово,
	позволяющее определить новую 
	или перепреоделить уже существующую функцию.
	Переопределение встроенных функций приводит к ошибке.

Массивы
~~~~~~~
Представляют из себя набор переменных,
В crypti все массивы являются ассоциативными, т.е. индексом массива
может быть как числа так и строки.
Индекс состоит из перечисленных через раздельный символ выражений
и указывается в квадратных скобках.
За счёт этого достигается эмуляция многомерных массивов.

Примеры опеределения массивов:
	arr[1] = "my";
	arr["name"] = 1;
	arr["job"] = "programming";
	arr["example", "of", "multidimentional", "array"] = "there";

Инициализация

Массивы определяются с помощью перечисленных через запятую пар ключ => значение,
заключённых в фигурные скобки, где ключ служет индексом в массиве для доступа
к этому значению.
Например:
	arr = {"one" => 1, "two" => 2}
Так же элементы массива можно определить по очереди
Например написанное выше можно переписать как:
	arr["one"] = 1; arr["two"] = 2

Если в определении ключи отсутствуют то по умолчанию значения размещаются в ячейках
с индексом начиная с 0 и далее.
Например:
	arr = {"one", 2, 3, "some"}
	значение "one" будет доступно при обращении arr[0],
	значение 2 при обращении arr[1] и так далее.

Доступ к элементам.
Доступ к элементам массива происходит посредством передачи значения
между квадратными скобками.
Например:
	arr[1]
	arr["two"]
	arr["42"]
Попытка доступа к несуществующему элементу будет приводить к <Runtime error>
	
Переменные
~~~~~~~~~~
Переменная - это идентификатор и связанная с ним область данных.
Тип переменной динамически определяется во время использования.

Операторы
~~~~~~~~~
Ниже приведён список доступных операторов.
Если не будет указано обратное то операторы бинарные. 
Синтаксис использования бинарных операторов a OP b. где a и b операнды - переменные или выражения
стоящие слева и справа от оператора.

Арифметические, логические, побитовые операторы представляют операнды как числа а затем выполняют
одну из следующих операций.


Арифметические операторы:
	OP:	Описание
	+ 	Складывает a и b.
	- 	Вычитает b из a.
	*	Перемножает a и b.
	/	Делит a на b.
	**	Возводит a в степень b.
	%	Находит отстаток от деления a на b.
	+	Унарный оператор. Синтаксис использования: +a.
		Возвращает значение числа a.
	-	Унарный оператор. Синтаксис использования: -a.
       		Находит арифметически обратное число для a.

Логические операторы:
	&&	Находит результат логического И a и b.
	||	Находит результат логического ИЛИ a и b.
	!	Унарный оператор. Синтаксис использования: !a. Находит логическое НЕ a.
	==	проверяет равны ли a и b.

Побитовые операторы:
	^	Находит результат исключающего ИЛИ a и b.
		Дополняет старшие разряды меньшего числа нулями.
	|	Находит результат бинарного ИЛИ a и b.
		Дополняет старшие разряды меньшего числа нулями.
	&	Находит результат бинарного ИЛИ a и b.
		Дополняет старшие разряды меньшего числа нулями.
	>>	Сдвигает a на b разрядов вправо
	<<	Сдвигает a на b разрядов влево
	~	Унарный оператор. Синтаксис использования: ~a. Находит побитовое НЕ a.


Операторы присваивания:

	=	присваивает a значение b
		Доступно параллельное присваивание.
		Например:
			[a, b] = [b, a]
			[n, l, y] = func_with_3_outputs()
	op=	Выполняет операцию op с a и b, затем присваивает a получившийся результат.

Операторы с октетными строками
Представляют операнды как октетные строки и выполняют операцию.
	#	 Выполняет конкатенацию a и b

Операторы с печатными строками
Представляют операнды как печатные строки и выполняют операцию.
	 (пробел) Выполняет конкатенацию a и b
Прочие операторы:
	.	Синтаксис: a.b. операция взятия атрибута b у переменной a.
		попытка взятия не существующего атрибута приводит к <Runtime error>
	

Приоритетность
	В таблице, приведённой ниже операторы перечисленны
	по возрастающей приоритетности.

	ТАБЛИЦА(приоритетность стырить из С)
	a[]			LR
	a.b			LR
	**			RL
	~			LR
	+a -a			LR
	* / %			LR
	+ -			LR
	<< >>			LR
	< <= >= 		LR
	== !=			LR
	&			LR
	^			LR
	|			LR
	&&			LR
	!			LR
	||			LR
	= op=			RL


	Обозначения:
		LR очерёдность слева на право.
		RL очерёдность справа на лево.

Функции
~~~~~~~
Функции - набор логически выделенных инструкций, вызываемых по требованию.
В crypti все определённые функции (включая встроеные) хрянятся в отдельной
таблице, однако во избежание путанницы интерпретатор реализован так,
что функции не могут иметь те же имена что переменные.
По умолчанию параметры, переданные в функцию передаются как копии.
То есть их изменение внутри функции не повлияет
на значения после вызова.
Возвращаемые значения записываются в квадратных скобках при определении функции.
При достижении конца функции или ключевого слова return возвращаются их текущие значения
Если на момент выхода из функции одно или несколько значений не определены - 
генерируется <Runtime error>

Пример:
	a = 2
	def [] func(SOME_WORD b) {
		b += 2;
	}
	func(a);

После вызова функции func a будет равно 4

Определение
	Определение функции заносит новую функцию в таблицу,
	если функция уже присутствует в таблице и не является
	встроенной, то старое определение заменится новым.
	Переопределение встроенных функций не допускается.

	Функция определяется таким образом:

	def [ret1, ret2] func_name(parameter_list) {
		body
	}

	Где:
	[ret1, ret2] - список возвращаемых функцией аргументов (который может быть пустым)
	func_name - идентификатор,
	являющийся именем функции.
	parameter_list - перечисленные через запятую идентификаторы, являющиеся аргументами функции
	body - набор инструкций, выполняемых при вызове функции.
	Для блока инструкций внутри тела функции создаётся
	отдельная область видимости (см. Области видимости),
	локальные переменные определённые в ней пропадают
	в момент выхода из функции.

Вызов
	Вызов функции осуществляется с помощью конструкции

	func_name(parameter_list)

	Где:
	func_name - идентификатор уже определённой функции.
	parameter_name - перечисленные через запятую выражения,
	результаты которых будут являться аргументами функции.

	builtin функции.

	В Crypti содержится несколько встроеных функций,
	Эти функции не могут быть переопределены или удалены 
	они всегда доступны для вызова.
	Ниже в алфавитном порядке перечисленны сами функции.

	del(var)
		Удаляет переменную из ближайшей области видимости,
		и освобождает всю занимаемую ей память.

	print(var, ...);
		выводит на stdout переданные аргументы.

	printf([format_string], ...)
		Выводит на stdout переданные аргументы в соответствии с форматной строкой.
		При нехватке/переизбытке агрументов указанных в форматной строке печатает
		предупредительное соообщение

Области видимости
~~~~~~~~~~~~~~~~~
Область видимости содержит в себе набор
имён переменных и ассоциированных с ними данных.

Для каждого блока инструкций обрамлённого символами '{' и '}'
и для каждого вызова функции создаётся своя область видимости.
	Пример:
		{
			a = 2
			b = 4
		}
Это значит что все определённые в этой области видимости переменные
доступны только в этой области видимости,
и доступ к ним при выходе из этой области невозможен.
Поиск переменной происходит от текущей области видимости к глобальной.
Это значит что программа может пользоваться переменными из области
видимости меньшего уровня вложенности.

	Глобальная область видимости.
		Внешняя область видимости.
		В ней доступны инструкции для подключения модулей,
		возможость определения новых функций.

	Локальные области видимости.
		

Модули
------
Модуль это файл, написаный на языке crypti и импортированный в программу
с помощью инструкции import.
Все функции и переменные, определённые в модуле,
импортируются в глобальную область видимости.
для предотвращения бесконечного импортирования модулей
(например когда модуль А импортирует модуль Б,
а тот в свою очередь импортирует модуль А)
информация об импортированном модуле заносится в таблицу импорта.
При каждой новой попытке импорта проверяется таблица импорта,
и если данный модуль уже импортирован, то запрос импорта пропускается.
Это означает что если произошёл импорт,
и затем произошли изменения в модуле то не существует никакого способа
обновления данных модуля. Возможно в следующих версиях интерпретатора
будет реализована специальная инструкция "require",
с помощью которой будет доступна перезагрузка содержания модуля.

Подключение 
~~~~~~~~~~~
Модули подключаются с помощью ключевого слова import.
Если подключается модуль из стандартной библиотеки то
имя модуля обрамляется символами '<' и '>'.
Пример:
	import <crypto>
Если подключается файл, определённый пользователем,
то указывается относительный от данного каталога путь,
обрамлённый символами двойной кавычки.
Пример:
	import "crypto"

Стандартные пути расположения модулей


Стандартная библиотека.
~~~~~~~~~~~~~~~~~~~~~~
Описание модулей

1. crypto
[res] mod_inv(num, modulo)
	Находит обратное num число по модулю modulo.

[res] mod_exp(n, exp, modulo)
	Вычисляет
	(n ** exp) % modulo
	
[res] rand_prime(len)
	Генерирует случайное число длиннной len байт.

[ctx] md5_ctx_new()
[] md5_ctx_update(ctx, msg)
[digest] md5_ctx_final(ctx)

[ctx] whirpool_ctx_new()
[] whirpool_ctx_update(ctx, msg)
[digest] whirpool_ctx_final(ctx)

[ctx] sha1_ctx_new()
[] sha1_ctx_update(ctx, msg)
[digest] sha1_ctx_final(ctx)

[ctx] sha256_ctx_new()
[] sha256_ctx_update(ctx, msg)
[digest] sha256_ctx_final(ctx)

[ctx] aes_ctx_new()
[] aes_set_key(ctx, key, keylen)
[out] aes_encrypt(ctx, in)
[out] aes_decrypt(ctx, in)

=============================================================
//WIP
rsa
режимы шифрования
=============================================================

2. stdio
num_from_file()
fopen()
fclose()
fread()
fwrite()

3.random

4.string

[string] new_string(len, filler)
	Возвращает новую строку len байт длинны,
	каждый байт которой равен filler.
[sub] subs(string, start, len)
	Возвращает копию подстроки начиная с start,
	len байт длинной.

